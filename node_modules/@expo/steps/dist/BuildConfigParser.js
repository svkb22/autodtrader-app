"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildConfigParser = void 0;
const assert_1 = __importDefault(require("assert"));
const AbstractConfigParser_1 = require("./AbstractConfigParser");
const BuildConfig_1 = require("./BuildConfig");
const BuildFunction_1 = require("./BuildFunction");
const BuildFunctionGroup_1 = require("./BuildFunctionGroup");
const BuildStep_1 = require("./BuildStep");
const BuildStepInput_1 = require("./BuildStepInput");
const BuildStepOutput_1 = require("./BuildStepOutput");
const errors_1 = require("./errors");
class BuildConfigParser extends AbstractConfigParser_1.AbstractConfigParser {
    configPath;
    constructor(ctx, { configPath, externalFunctions, externalFunctionGroups, }) {
        super(ctx, {
            externalFunctions,
            externalFunctionGroups,
        });
        this.configPath = configPath;
    }
    async parseConfigToBuildStepsAndBuildFunctionByIdMappingAsync() {
        const config = await (0, BuildConfig_1.readAndValidateBuildConfigFromPathAsync)(this.configPath, {
            externalFunctionIds: this.getExternalFunctionFullIds(),
            externalFunctionGroupsIds: this.getExternalFunctionGroupFullIds(),
        });
        const configBuildFunctions = this.createBuildFunctionsFromConfig(config.functions);
        const buildFunctions = this.mergeBuildFunctionsWithExternal(configBuildFunctions, this.externalFunctions);
        const buildFunctionGroups = (0, BuildFunctionGroup_1.createBuildFunctionGroupByIdMapping)(this.externalFunctionGroups ?? []);
        const buildSteps = [];
        for (const stepConfig of config.build.steps) {
            buildSteps.push(...this.createBuildStepFromConfig(stepConfig, buildFunctions, buildFunctionGroups));
        }
        return {
            buildSteps,
            buildFunctionById: buildFunctions,
        };
    }
    createBuildStepFromConfig(buildStepConfig, buildFunctions, buildFunctionGroups) {
        if ((0, BuildConfig_1.isBuildStepCommandRun)(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepCommandRun(buildStepConfig)];
        }
        else if ((0, BuildConfig_1.isBuildStepBareCommandRun)(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepBareCommandRun(buildStepConfig)];
        }
        else if ((0, BuildConfig_1.isBuildStepBareFunctionOrFunctionGroupCall)(buildStepConfig)) {
            return this.createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else if (buildStepConfig !== null) {
            return this.createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else {
            throw new errors_1.BuildConfigError('Invalid build step configuration detected. Build step cannot be empty.');
        }
    }
    createBuildStepFromBuildStepCommandRun({ run }) {
        const { id: maybeId, inputs: inputsConfig, outputs: outputsConfig, name, workingDirectory, shell, command, env, if: ifCondition, timeout_minutes, __metrics_id, } = run;
        const id = BuildStep_1.BuildStep.getNewId(maybeId);
        const displayName = BuildStep_1.BuildStep.getDisplayName({ id, name, command });
        const inputs = inputsConfig && this.createBuildStepInputsFromDefinition(inputsConfig, displayName);
        const outputs = outputsConfig && this.createBuildStepOutputsFromDefinition(outputsConfig, displayName);
        const timeoutMs = timeout_minutes !== undefined ? timeout_minutes * 60 * 1000 : undefined;
        return new BuildStep_1.BuildStep(this.ctx, {
            id,
            inputs,
            outputs,
            name,
            displayName,
            workingDirectory,
            shell,
            command,
            env,
            ifCondition,
            timeoutMs,
            __metricsId: __metrics_id,
        });
    }
    createBuildStepFromBuildStepBareCommandRun({ run: command, }) {
        const id = BuildStep_1.BuildStep.getNewId();
        const displayName = BuildStep_1.BuildStep.getDisplayName({ id, command });
        return new BuildStep_1.BuildStep(this.ctx, {
            id,
            displayName,
            command,
        });
    }
    createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionGroup = buildFunctionGroups[functionId];
        (0, assert_1.default)(buildFunctionGroup, `Build function group with id "${functionId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx, {
            callInputs: buildStepFunctionCall[functionId].inputs,
        });
    }
    createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionGroupId) {
        const buildFunctionGroup = buildFunctionGroups[functionGroupId];
        (0, assert_1.default)(buildFunctionGroup, `Build function group with id "${functionGroupId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx);
    }
    createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionId) {
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx);
    }
    createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, functionOrFunctionGroupId) {
        const maybeFunctionGroup = buildFunctionGroups[functionOrFunctionGroupId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionOrFunctionGroupId);
        }
        return [
            this.createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionOrFunctionGroupId),
        ];
    }
    createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const maybeFunctionGroup = buildFunctionGroups[functionId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall);
        }
        return [this.createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall)];
    }
    createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionCallConfig = buildStepFunctionCall[functionId];
        const buildFunction = buildFunctions[functionId];
        const timeoutMs = buildFunctionCallConfig.timeout_minutes !== undefined
            ? buildFunctionCallConfig.timeout_minutes * 60 * 1000
            : undefined;
        return buildFunction.createBuildStepFromFunctionCall(this.ctx, {
            id: buildFunctionCallConfig.id,
            name: buildFunctionCallConfig.name,
            callInputs: buildFunctionCallConfig.inputs,
            workingDirectory: buildFunctionCallConfig.workingDirectory,
            shell: buildFunctionCallConfig.shell,
            env: buildFunctionCallConfig.env,
            ifCondition: buildFunctionCallConfig.if,
            timeoutMs,
        });
    }
    createBuildFunctionsFromConfig(buildFunctionsConfig) {
        if (!buildFunctionsConfig) {
            return {};
        }
        const result = {};
        for (const [functionId, buildFunctionConfig] of Object.entries(buildFunctionsConfig)) {
            const buildFunction = this.createBuildFunctionFromConfig({
                id: functionId,
                ...buildFunctionConfig,
            });
            result[buildFunction.getFullId()] = buildFunction;
        }
        return result;
    }
    createBuildFunctionFromConfig({ id, name, inputs: inputsConfig, outputs: outputsConfig, shell, command, supportedRuntimePlatforms, path: customFunctionModulePath, }) {
        const inputProviders = inputsConfig && this.createBuildStepInputProvidersFromBuildFunctionInputs(inputsConfig);
        const outputProviders = outputsConfig && this.createBuildStepOutputProvidersFromBuildFunctionOutputs(outputsConfig);
        return new BuildFunction_1.BuildFunction({
            id,
            name,
            inputProviders,
            outputProviders,
            shell,
            command,
            customFunctionModulePath,
            supportedRuntimePlatforms,
        });
    }
    createBuildStepInputsFromDefinition(buildStepInputs, stepDisplayName) {
        return Object.entries(buildStepInputs).map(([key, value]) => new BuildStepInput_1.BuildStepInput(this.ctx, {
            id: key,
            stepDisplayName,
            defaultValue: value,
            required: true,
            allowedValueTypeName: typeof value === 'object'
                ? BuildStepInput_1.BuildStepInputValueTypeName.JSON
                : typeof value,
        }));
    }
    createBuildStepInputProvidersFromBuildFunctionInputs(buildFunctionInputs) {
        return buildFunctionInputs.map(entry => {
            return typeof entry === 'string'
                ? BuildStepInput_1.BuildStepInput.createProvider({
                    id: entry,
                    required: true,
                    allowedValueTypeName: BuildStepInput_1.BuildStepInputValueTypeName.STRING,
                })
                : BuildStepInput_1.BuildStepInput.createProvider({
                    id: entry.name,
                    required: entry.required ?? true,
                    defaultValue: entry.defaultValue,
                    allowedValues: entry.allowedValues,
                    allowedValueTypeName: entry.allowedValueType,
                });
        });
    }
    createBuildStepOutputsFromDefinition(buildStepOutputs, stepDisplayName) {
        return buildStepOutputs.map(entry => typeof entry === 'string'
            ? new BuildStepOutput_1.BuildStepOutput(this.ctx, { id: entry, stepDisplayName, required: true })
            : new BuildStepOutput_1.BuildStepOutput(this.ctx, {
                id: entry.name,
                stepDisplayName,
                required: entry.required ?? true,
            }));
    }
    createBuildStepOutputProvidersFromBuildFunctionOutputs(buildFunctionOutputs) {
        return buildFunctionOutputs.map(entry => typeof entry === 'string'
            ? BuildStepOutput_1.BuildStepOutput.createProvider({ id: entry, required: true })
            : BuildStepOutput_1.BuildStepOutput.createProvider({ id: entry.name, required: entry.required ?? true }));
    }
    mergeBuildFunctionsWithExternal(configFunctions, externalFunctions) {
        const result = { ...configFunctions };
        if (externalFunctions === undefined) {
            return result;
        }
        for (const buildFunction of externalFunctions) {
            // functions defined in config shadow the external ones
            const fullId = buildFunction.getFullId();
            if (!(fullId in result)) {
                result[fullId] = buildFunction;
            }
        }
        return result;
    }
}
exports.BuildConfigParser = BuildConfigParser;
function getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall) {
    const keys = Object.keys(buildStepFunctionCall);
    (0, assert_1.default)(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
    return keys[0];
}
