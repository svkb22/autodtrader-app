"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildFunction = void 0;
const assert_1 = __importDefault(require("assert"));
const BuildStep_1 = require("./BuildStep");
const customFunction_1 = require("./utils/customFunction");
class BuildFunction {
    namespace;
    id;
    name;
    supportedRuntimePlatforms;
    inputProviders;
    outputProviders;
    command;
    customFunctionModulePath;
    fn;
    shell;
    __metricsId;
    constructor({ namespace, id, name, supportedRuntimePlatforms, inputProviders, outputProviders, command, fn, customFunctionModulePath, shell, __metricsId, }) {
        (0, assert_1.default)(command !== undefined || fn !== undefined || customFunctionModulePath !== undefined, 'Either command, fn or path must be defined.');
        (0, assert_1.default)(!(command !== undefined && fn !== undefined), 'Command and fn cannot be both set.');
        (0, assert_1.default)(!(command !== undefined && customFunctionModulePath !== undefined), 'Command and path cannot be both set.');
        (0, assert_1.default)(!(fn !== undefined && customFunctionModulePath !== undefined), 'Fn and path cannot be both set.');
        this.namespace = namespace;
        this.id = id;
        this.name = name;
        this.supportedRuntimePlatforms = supportedRuntimePlatforms;
        this.inputProviders = inputProviders;
        this.outputProviders = outputProviders;
        this.command = command;
        this.fn = fn;
        this.shell = shell;
        this.customFunctionModulePath = customFunctionModulePath;
        this.__metricsId = __metricsId;
    }
    getFullId() {
        return this.namespace === undefined ? this.id : `${this.namespace}/${this.id}`;
    }
    createBuildStepFromFunctionCall(ctx, { id, name, callInputs = {}, workingDirectory, shell, env, ifCondition, timeoutMs, } = {}) {
        const buildStepId = BuildStep_1.BuildStep.getNewId(id);
        const buildStepName = name ?? this.name;
        const buildStepDisplayName = BuildStep_1.BuildStep.getDisplayName({
            id: buildStepId,
            command: this.command,
            name: buildStepName,
        });
        const inputs = this.inputProviders?.map(inputProvider => {
            const input = inputProvider(ctx, buildStepId);
            if (input.id in callInputs) {
                input.set(callInputs[input.id]);
            }
            return input;
        });
        const outputs = this.outputProviders?.map(outputProvider => outputProvider(ctx, buildStepId));
        return new BuildStep_1.BuildStep(ctx, {
            id: buildStepId,
            name: buildStepName,
            displayName: buildStepDisplayName,
            command: this.command,
            fn: this.fn ??
                (this.customFunctionModulePath
                    ? (0, customFunction_1.createCustomFunctionCall)(this.customFunctionModulePath)
                    : undefined),
            workingDirectory,
            inputs,
            outputs,
            shell,
            supportedRuntimePlatforms: this.supportedRuntimePlatforms,
            env,
            ifCondition,
            timeoutMs,
            __metricsId: this.__metricsId,
        });
    }
}
exports.BuildFunction = BuildFunction;
