"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildStepContext = exports.BuildStepGlobalContext = void 0;
const fast_glob_1 = __importDefault(require("fast-glob"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const BuildStep_1 = require("./BuildStep");
const errors_1 = require("./errors");
const hashFiles_1 = require("./utils/hashFiles");
const template_1 = require("./utils/template");
class BuildStepGlobalContext {
    provider;
    skipCleanup;
    stepsInternalBuildDirectory;
    runtimePlatform;
    baseLogger;
    didCheckOut = false;
    _hasAnyPreviousStepFailed = false;
    stepById = {};
    _stepMetrics = [];
    constructor(provider, skipCleanup) {
        this.provider = provider;
        this.skipCleanup = skipCleanup;
        this.stepsInternalBuildDirectory = path_1.default.join(os_1.default.tmpdir(), 'eas-build', (0, uuid_1.v4)());
        this.runtimePlatform = provider.runtimePlatform;
        this.baseLogger = provider.logger;
        this._hasAnyPreviousStepFailed = false;
    }
    get projectSourceDirectory() {
        return this.provider.projectSourceDirectory;
    }
    get projectTargetDirectory() {
        return this.provider.projectTargetDirectory;
    }
    get defaultWorkingDirectory() {
        return this.didCheckOut ? this.provider.defaultWorkingDirectory : this.projectTargetDirectory;
    }
    get buildLogsDirectory() {
        return this.provider.buildLogsDirectory;
    }
    get env() {
        return this.provider.env;
    }
    get staticContext() {
        return {
            ...this.provider.staticContext(),
            steps: Object.fromEntries(Object.values(this.stepById).map(step => [
                step.id,
                {
                    outputs: Object.fromEntries(step.outputs.map(output => {
                        return [output.id, output.rawValue];
                    })),
                },
            ])),
        };
    }
    updateEnv(updatedEnv) {
        this.provider.updateEnv(updatedEnv);
    }
    registerStep(step) {
        this.stepById[step.id] = step;
    }
    getStepOutputValue(path) {
        const { stepId, outputId } = (0, template_1.parseOutputPath)(path);
        if (!(stepId in this.stepById)) {
            throw new errors_1.BuildStepRuntimeError(`Step "${stepId}" does not exist.`);
        }
        return this.stepById[stepId].getOutputValueByName(outputId);
    }
    getInterpolationContext() {
        const hasAnyPreviousStepFailed = this.hasAnyPreviousStepFailed;
        return {
            ...this.staticContext,
            always: () => true,
            never: () => false,
            success: () => !hasAnyPreviousStepFailed,
            failure: () => hasAnyPreviousStepFailed,
            env: this.env,
            fromJSON: (json) => JSON.parse(json),
            toJSON: (value) => JSON.stringify(value),
            contains: (value, substring) => value.includes(substring),
            startsWith: (value, prefix) => value.startsWith(prefix),
            endsWith: (value, suffix) => value.endsWith(suffix),
            hashFiles: (...patterns) => this.hashFiles(...patterns),
            replaceAll: (input, stringToReplace, replacementString) => {
                while (input.includes(stringToReplace)) {
                    input = input.replace(stringToReplace, replacementString);
                }
                return input;
            },
            substring: (input, start, end) => input.substring(start, end),
        };
    }
    interpolate(value) {
        return (0, template_1.interpolateWithGlobalContext)(value, path => {
            return ((0, template_1.getObjectValueForInterpolation)(path, {
                eas: {
                    runtimePlatform: this.runtimePlatform,
                    ...this.staticContext,
                    env: this.env,
                },
            })?.toString() ?? '');
        });
    }
    stepCtx(options) {
        return new BuildStepContext(this, options);
    }
    markAsCheckedOut(logger) {
        this.didCheckOut = true;
        logger.info(`Changing default working directory to ${this.defaultWorkingDirectory} (was ${this.projectTargetDirectory})`);
    }
    get hasAnyPreviousStepFailed() {
        return this._hasAnyPreviousStepFailed;
    }
    markAsFailed() {
        this._hasAnyPreviousStepFailed = true;
    }
    get stepMetrics() {
        return this._stepMetrics;
    }
    addStepMetric(metric) {
        this._stepMetrics.push({ ...metric, platform: this.runtimePlatform });
    }
    wasCheckedOut() {
        return this.didCheckOut;
    }
    hashFiles(...patterns) {
        const cwd = this.defaultWorkingDirectory;
        const workspacePath = path_1.default.resolve(cwd);
        // Use glob to find matching files across all patterns
        const filePaths = fast_glob_1.default.sync(patterns, {
            cwd,
            absolute: true,
            onlyFiles: true,
        });
        if (filePaths.length === 0) {
            return '';
        }
        const validFilePaths = filePaths.filter(file => file.startsWith(`${workspacePath}${path_1.default.sep}`));
        if (validFilePaths.length === 0) {
            return '';
        }
        return (0, hashFiles_1.hashFiles)(validFilePaths);
    }
    serialize() {
        return {
            stepsInternalBuildDirectory: this.stepsInternalBuildDirectory,
            stepById: Object.fromEntries(Object.entries(this.stepById).map(([id, step]) => [id, step.serialize()])),
            provider: {
                projectSourceDirectory: this.provider.projectSourceDirectory,
                projectTargetDirectory: this.provider.projectTargetDirectory,
                defaultWorkingDirectory: this.provider.defaultWorkingDirectory,
                buildLogsDirectory: this.provider.buildLogsDirectory,
                runtimePlatform: this.provider.runtimePlatform,
                staticContext: this.provider.staticContext(),
                env: this.provider.env,
            },
            skipCleanup: this.skipCleanup,
        };
    }
    static deserialize(serialized, logger) {
        const deserializedProvider = {
            projectSourceDirectory: serialized.provider.projectSourceDirectory,
            projectTargetDirectory: serialized.provider.projectTargetDirectory,
            defaultWorkingDirectory: serialized.provider.defaultWorkingDirectory,
            buildLogsDirectory: serialized.provider.buildLogsDirectory,
            runtimePlatform: serialized.provider.runtimePlatform,
            logger,
            staticContext: () => serialized.provider.staticContext,
            env: serialized.provider.env,
            updateEnv: () => { },
        };
        const ctx = new BuildStepGlobalContext(deserializedProvider, serialized.skipCleanup);
        for (const [id, stepOutputAccessor] of Object.entries(serialized.stepById)) {
            ctx.stepById[id] = BuildStep_1.BuildStepOutputAccessor.deserialize(stepOutputAccessor);
        }
        ctx.stepsInternalBuildDirectory = serialized.stepsInternalBuildDirectory;
        return ctx;
    }
}
exports.BuildStepGlobalContext = BuildStepGlobalContext;
class BuildStepContext {
    ctx;
    logger;
    relativeWorkingDirectory;
    constructor(ctx, { logger, relativeWorkingDirectory, }) {
        this.ctx = ctx;
        this.logger = logger ?? ctx.baseLogger;
        this.relativeWorkingDirectory = relativeWorkingDirectory;
    }
    get global() {
        return this.ctx;
    }
    get workingDirectory() {
        if (!this.relativeWorkingDirectory) {
            return this.ctx.defaultWorkingDirectory;
        }
        if (path_1.default.isAbsolute(this.relativeWorkingDirectory)) {
            return path_1.default.join(this.ctx.projectTargetDirectory, this.relativeWorkingDirectory);
        }
        return path_1.default.join(this.ctx.defaultWorkingDirectory, this.relativeWorkingDirectory);
    }
    serialize() {
        return {
            relativeWorkingDirectory: this.relativeWorkingDirectory,
            global: this.ctx.serialize(),
        };
    }
    static deserialize(serialized, logger) {
        const deserializedGlobal = BuildStepGlobalContext.deserialize(serialized.global, logger);
        return new BuildStepContext(deserializedGlobal, {
            logger,
            relativeWorkingDirectory: serialized.relativeWorkingDirectory,
        });
    }
}
exports.BuildStepContext = BuildStepContext;
